## Code Vulnerability Scanning (SAST)

### What It Is

Static Application Security Testing. Analyze code without running it.

---

## What Can Be Detected

### High Confidence (Easy to Detect)

| Vulnerability            | Pattern                         | Example                                    |
| ------------------------ | ------------------------------- | ------------------------------------------ |
| SQL Injection            | String concatenation in queries | `"SELECT * FROM users WHERE id=" + id`     |
| Hardcoded secrets        | API keys, passwords in code     | `api_key = "sk-1234..."`                   |
| XSS (Reflected)          | User input in HTML output       | `res.send("<div>" + userInput + "</div>")` |
| Path traversal           | User input in file paths        | `fs.readFile("./uploads/" + filename)`     |
| Command injection        | User input in shell commands    | `exec("ls " + userInput)`                  |
| Insecure deserialization | Deserializing untrusted data    | `pickle.loads(user_data)`                  |
| Weak crypto              | MD5, SHA1, DES                  | `hashlib.md5(password)`                    |
| Hardcoded IPs/URLs       | Environment-specific values     | `const API = "http://192.168.1.1"`         |
| Debug code left in       | Console logs, debug flags       | `DEBUG = True`                             |
| Insecure randomness      | Math.random for security        | `token = Math.random().toString()`         |

---

### Medium Confidence (Context Needed)

| Vulnerability           | Pattern              | Challenge                    |
| ----------------------- | -------------------- | ---------------------------- |
| IDOR                    | Missing auth checks  | Need to understand data flow |
| SSRF                    | URL from user input  | Need to trace input source   |
| XXE                     | XML parsing          | Depends on parser config     |
| Open redirect           | Redirect to user URL | Need to trace input          |
| Mass assignment         | Binding all params   | Framework-dependent          |
| Sensitive data exposure | Logging PII          | Need to identify PII fields  |

---

### Hard to Detect (Needs Deep Analysis)

| Vulnerability         | Why Hard                     |
| --------------------- | ---------------------------- |
| Business logic flaws  | Need domain knowledge        |
| Race conditions       | Need execution flow analysis |
| Authentication bypass | Complex state machines       |
| Authorization flaws   | Need role understanding      |
| Timing attacks        | Need performance analysis    |

---

## Tools Available

### Open Source

| Tool                  | Languages  | Speed  | Quality   |
| --------------------- | ---------- | ------ | --------- |
| **Semgrep**           | All major  | Fast   | Excellent |
| **Bandit**            | Python     | Fast   | Good      |
| **ESLint (security)** | JavaScript | Fast   | Good      |
| **Brakeman**          | Ruby       | Fast   | Excellent |
| **GoSec**             | Go         | Fast   | Good      |
| **SpotBugs**          | Java       | Medium | Good      |
| **PHPStan**           | PHP        | Fast   | Good      |

### Commercial

| Tool          | Cost    | Quality   |
| ------------- | ------- | --------- |
| **Snyk Code** | Free-$$ | Excellent |
| **SonarQube** | Free-$$ | Excellent |
| **Checkmarx** | $$$$    | Excellent |
| **Veracode**  | $$$$    | Excellent |
| **Fortify**   | $$$$    | Excellent |

---

## Semgrep: Best Choice for Yantra

### Why Semgrep

| Aspect              | Benefit                              |
| ------------------- | ------------------------------------ |
| Open source         | Free, no API limits                  |
| Fast                | Scans 100K LOC in seconds            |
| Multi-language      | JS, TS, Python, Go, Java, Ruby, etc. |
| Custom rules        | Write Yantra-specific patterns       |
| Low false positives | Pattern-based, not heuristic         |
| Easy integration    | CLI, CI/CD, API                      |
| Active community    | 2000+ rules available                |

---

### Semgrep Example

**Rule:**

```yaml
rules:
  - id: sql-injection
    pattern: |
      $QUERY = "..." + $INPUT + "..."
      ...
      $DB.query($QUERY, ...)
    message: 'Potential SQL injection'
    severity: ERROR
    languages: [javascript, typescript]
```

**Detects:**

```javascript
// BAD - Detected
const query = 'SELECT * FROM users WHERE id=' + userId;
db.query(query);

// GOOD - Not flagged
const query = 'SELECT * FROM users WHERE id=$1';
db.query(query, [userId]);
```

---

## Yantra Integration

### Architecture

```
Code generated/modified
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Yantra Security Scanner                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Semgrep    â”‚  â”‚   Secret    â”‚  â”‚ Dependency  â”‚        â”‚
â”‚  â”‚  (SAST)     â”‚  â”‚  Detection  â”‚  â”‚   Scan      â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚         â”‚                â”‚                â”‚                â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                          â”‚                                 â”‚
â”‚                          â–¼                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚              LLM Analysis                        â”‚      â”‚
â”‚  â”‚                                                  â”‚      â”‚
â”‚  â”‚  - Filter false positives                       â”‚      â”‚
â”‚  â”‚  - Assess exploitability                        â”‚      â”‚
â”‚  â”‚  - Generate fixes                               â”‚      â”‚
â”‚  â”‚  - Prioritize by severity                       â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                          â”‚                                 â”‚
â”‚                          â–¼                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚              Auto-Fix                            â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Implementation

```rust
struct SecurityScanner {
    semgrep: SemgrepRunner,
    secret_detector: SecretDetector,
    dependency_scanner: DependencyScanner,
    llm: LlmClient,
}

impl SecurityScanner {
    async fn scan(&self, codebase: &Path) -> SecurityReport {
        // Run all scanners in parallel
        let (sast, secrets, deps) = tokio::join!(
            self.semgrep.scan(codebase),
            self.secret_detector.scan(codebase),
            self.dependency_scanner.scan(codebase),
        );

        let all_findings = vec![sast, secrets, deps].concat();

        // LLM filters and analyzes
        let analyzed = self.analyze_with_llm(all_findings).await?;

        SecurityReport {
            findings: analyzed,
            summary: self.generate_summary(&analyzed),
        }
    }

    async fn analyze_with_llm(&self, findings: Vec<Finding>) -> Vec<AnalyzedFinding> {
        let prompt = format!(
            "Analyze these security findings:

             {findings}

             For each finding:
             1. Is this a real vulnerability or false positive?
             2. How exploitable is it?
             3. What's the impact if exploited?
             4. Provide a specific code fix.

             Prioritize by actual risk, not just severity label.",
            findings = serde_json::to_string(&findings)?
        );

        self.llm.generate(&prompt).await
    }
}
```

---

### Semgrep Runner

```rust
struct SemgrepRunner {
    rules_path: PathBuf,
}

impl SemgrepRunner {
    async fn scan(&self, codebase: &Path) -> Vec<Finding> {
        let output = Command::new("semgrep")
            .args([
                "--config", "p/security-audit",
                "--config", "p/owasp-top-ten",
                "--config", &self.rules_path.to_string(),
                "--json",
                codebase.to_str().unwrap(),
            ])
            .output()
            .await?;

        let results: SemgrepOutput = serde_json::from_slice(&output.stdout)?;

        results.results.into_iter().map(|r| Finding {
            rule_id: r.check_id,
            file: r.path,
            line: r.start.line,
            code: r.extra.lines,
            message: r.extra.message,
            severity: r.extra.severity,
        }).collect()
    }
}
```

---

### Secret Detection

```rust
struct SecretDetector;

impl SecretDetector {
    async fn scan(&self, codebase: &Path) -> Vec<Finding> {
        // Use gitleaks or trufflehog
        let output = Command::new("gitleaks")
            .args([
                "detect",
                "--source", codebase.to_str().unwrap(),
                "--report-format", "json",
                "--report-path", "/dev/stdout",
            ])
            .output()
            .await?;

        // Parse and return findings
    }

    // Custom patterns for common secrets
    fn custom_patterns() -> Vec<Regex> {
        vec![
            // AWS
            Regex::new(r"AKIA[0-9A-Z]{16}").unwrap(),
            // Stripe
            Regex::new(r"sk_live_[0-9a-zA-Z]{24}").unwrap(),
            // Generic API key
            Regex::new(r#"["']?api[_-]?key["']?\s*[:=]\s*["'][a-zA-Z0-9]{20,}"#).unwrap(),
            // Private key
            Regex::new(r"-----BEGIN (RSA |EC )?PRIVATE KEY-----").unwrap(),
            // JWT
            Regex::new(r"eyJ[a-zA-Z0-9]{10,}\.eyJ[a-zA-Z0-9]{10,}").unwrap(),
        ]
    }
}
```

---

### Dependency Scanner

```rust
struct DependencyScanner;

impl DependencyScanner {
    async fn scan(&self, codebase: &Path) -> Vec<Finding> {
        let mut findings = vec![];

        // Node.js
        if codebase.join("package.json").exists() {
            let output = Command::new("npm")
                .args(["audit", "--json"])
                .current_dir(codebase)
                .output()
                .await?;
            findings.extend(self.parse_npm_audit(&output.stdout));
        }

        // Python
        if codebase.join("requirements.txt").exists() {
            let output = Command::new("pip-audit")
                .args(["--format", "json"])
                .current_dir(codebase)
                .output()
                .await?;
            findings.extend(self.parse_pip_audit(&output.stdout));
        }

        // Go
        if codebase.join("go.mod").exists() {
            let output = Command::new("govulncheck")
                .args(["-json", "./..."])
                .current_dir(codebase)
                .output()
                .await?;
            findings.extend(self.parse_govulncheck(&output.stdout));
        }

        findings
    }
}
```

---

## LLM-Enhanced Analysis

### False Positive Filtering

```
Raw Semgrep output: 50 findings
        â”‚
        â–¼
LLM Analysis:
  "Finding #12: SQL injection in user_service.py:45

   Code: query = f'SELECT * FROM logs WHERE date={date}'

   Analysis: This appears to be a false positive.
   The 'date' variable comes from datetime.now(), not user input.
   Tracing backwards: date = datetime.now().strftime('%Y-%m-%d')

   Verdict: FALSE POSITIVE - safe internal value"
        â”‚
        â–¼
Filtered output: 23 real findings
```

---

### Auto-Fix Generation

```
Finding: SQL Injection in api/users.py:34

Original code:
  query = f"SELECT * FROM users WHERE id={user_id}"
  cursor.execute(query)

LLM generates fix:
  query = "SELECT * FROM users WHERE id=%s"
  cursor.execute(query, (user_id,))

Yantra applies fix automatically.
```

---

## User Interface

### Scan Results

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Security Scan Results                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚ Summary                                                     â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€                                                     â”‚
â”‚ Critical: 2   High: 5   Medium: 12   Low: 8                â”‚
â”‚                                                             â”‚
â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” â”‚
â”‚                                                             â”‚
â”‚ ğŸ”´ CRITICAL: SQL Injection                                  â”‚
â”‚    api/users.py:34                                         â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚    â”‚ query = f"SELECT * FROM users WHERE id={user_id}" â”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚    Impact: Full database access                            â”‚
â”‚    [View Fix] [Auto-Fix] [Ignore]                          â”‚
â”‚                                                             â”‚
â”‚ ğŸ”´ CRITICAL: Hardcoded API Key                             â”‚
â”‚    config/settings.py:12                                   â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚    â”‚ STRIPE_KEY = "sk_live_abc123..."                   â”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚    Impact: Financial data exposure                         â”‚
â”‚    [View Fix] [Auto-Fix] [Ignore]                          â”‚
â”‚                                                             â”‚
â”‚ ğŸŸ  HIGH: XSS Vulnerability                                  â”‚
â”‚    templates/profile.html:56                               â”‚
â”‚    [Expand]                                                 â”‚
â”‚                                                             â”‚
â”‚ [Auto-Fix All Critical] [Auto-Fix All] [Export Report]     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Fix Preview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Fix Preview: SQL Injection                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚ Before:                                                     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ def get_user(user_id):                                 â”‚ â”‚
â”‚ â”‚     query = f"SELECT * FROM users WHERE id={user_id}" â”‚ â”‚
â”‚ â”‚     cursor.execute(query)                              â”‚ â”‚
â”‚ â”‚     return cursor.fetchone()                           â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                             â”‚
â”‚ After:                                                      â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ def get_user(user_id):                                 â”‚ â”‚
â”‚ â”‚     query = "SELECT * FROM users WHERE id=%s"          â”‚ â”‚
â”‚ â”‚     cursor.execute(query, (user_id,))                  â”‚ â”‚
â”‚ â”‚     return cursor.fetchone()                           â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                             â”‚
â”‚ Explanation:                                                â”‚
â”‚ Using parameterized queries prevents SQL injection by      â”‚
â”‚ treating user input as data, not executable SQL.           â”‚
â”‚                                                             â”‚
â”‚              [Cancel] [Apply Fix]                           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Effort Estimate

| Component                | Effort      |
| ------------------------ | ----------- |
| Semgrep integration      | 1 week      |
| Custom Yantra rules      | 1 week      |
| Secret detection         | 1 week      |
| Dependency scanning      | 1 week      |
| LLM analysis integration | 2 weeks     |
| Auto-fix generation      | 2 weeks     |
| UI integration           | 1 week      |
| **Total**                | **9 weeks** |

---

## MVP vs Full

### MVP (5 weeks)

```
âœ… Semgrep with standard rules
âœ… Secret detection (gitleaks)
âœ… Dependency scan (npm audit, pip-audit)
âœ… Basic reporting
âœ… Manual fix suggestions

âŒ LLM false positive filtering
âŒ Auto-fix
âŒ Custom rules
```

### Full (9 weeks)

```
âœ… Everything in MVP
âœ… LLM analysis
âœ… Auto-fix generation
âœ… Custom Yantra rules
âœ… Rich UI
```

---

## Comparison

| Feature                | Cursor | Copilot | Snyk  | **Yantra** |
| ---------------------- | ------ | ------- | ----- | ---------- |
| SAST scanning          | âŒ     | âŒ      | âœ…    | âœ…         |
| Secret detection       | âŒ     | âŒ      | âœ…    | âœ…         |
| Dependency scan        | âŒ     | âŒ      | âœ…    | âœ…         |
| LLM analysis           | âŒ     | âŒ      | âŒ    | âœ…         |
| Auto-fix               | âŒ     | âŒ      | âš ï¸    | âœ…         |
| Integrated in workflow | N/A    | N/A     | CI/CD | âœ…         |

**Yantra advantage:** Security built into generation workflow, not separate tool.

---

## Bottom Line

### Is full code scan feasible?

**Yes. Very feasible.**

- Tools exist (Semgrep, gitleaks, npm audit)
- Well-defined patterns
- LLM enhances but not required
- Auto-fix is natural extension of Yantra

### Effort

| Scope | Time    |
| ----- | ------- |
| MVP   | 5 weeks |
| Full  | 9 weeks |

### Recommendation

**Include in MVP (basic version).**

- Semgrep standard rules
- Secret detection
- Dependency scanning
- Basic fix suggestions

**Phase 2: Add LLM analysis and auto-fix.**

**Value proposition:**

"Yantra generates secure code. Not just working code."
